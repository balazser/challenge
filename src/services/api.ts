import { Duration as Dur } from 'luxon'
import * as fp from 'lodash/fp'
import { Graph } from './pathFinder'
const response = require('./response')

const applyDiscount = (discount: number, price: number) => {
  return price - price * (discount / 100)
}

const getDuration = (d: Deal) =>
  Dur.fromObject({
    hours: parseInt(d.duration.h),
    minutes: parseInt(d.duration.m),
  })

const groupByDeparture = fp.groupBy<Deal>('departure')

const findFastest = (deals: Deal[]) => fp.minBy(getDuration, deals)
// const findCheapestDeal = fp.minBy(fp.prop('cost'))

const findCheapestDeal = fp.minBy<Deal>(d =>
  applyDiscount(fp.propOr(0, 'discount', d), d.cost)
)

export const fetchAll = (): Promise<any> => {
  const paths = response as PathsResponse
  const groupsDeparture = groupByDeparture(paths.deals)

  // cheapest
  const respOptimized = Object.values(groupsDeparture).map(d => {
    const groupsArrival = fp.groupBy<Deal>('arrival', d)
    return Object.values(groupsArrival).map(a => {
      if (a.length < 2) {
        return a
      }

      // + if there are more for same price find fastest
      return findCheapestDeal(a)
    })
  })

  return Promise.resolve({
    currency: paths.currency,
    deals: fp.flatten(respOptimized),
  })
}

export const buildGraph = (v: Deal[]) => {
  const mapped = Object.entries(groupByDeparture(v)).map(([k, v]) => {
    return {
      [k]: fp.mergeAll(
        v.map(d => {
          return { [fp.prop('arrival', d)]: d.cost }
        })
      ),
    }
  })
  return fp.mergeAll(mapped)
}

// Generated by https://quicktype.io

export interface PathsResponse {
  currency: string
  deals: Deal[]
}

export interface Deal {
  transport: Transport
  departure: string
  arrival: string
  duration: Duration
  cost: number
  discount: number
  reference: string
}

export interface Duration {
  h: string
  m: string
}

export enum Transport {
  Bus = 'bus',
  Car = 'car',
  Train = 'train',
}
